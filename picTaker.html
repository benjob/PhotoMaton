<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
	xmlns:h="http://xmlns.jcp.org/jsf/html"
	xmlns:f="http://xmlns.jcp.org/jsf/core">

<!--
	Ideally these elements aren't created until it's confirmed that the 
	client supports video/camera, but for the sake of illustrating the 
	elements involved, they are created with markup (not JavaScript)
-->
<head>

<style>

body {
    background-color: #EFE0B9;
    color: #333333;
	font-family: Arial, Helvetica, sans-serif;
    font-size:14px;
    word-wrap:break-word;
}

.crop {
  position:absolute;
  border:1px dashed white;
  cursor:move !important;
}

.resize-handle {
  position: absolute;
  bottom:0px;
  right:0px;
  width: 0px;
  height: 0px;
  border-style: solid;
  border-width: 0 0 16px 16px;
  border-color: transparent transparent #AAA transparent;
  cursor: nw-resize !important;
}

a, .button { /*for all buttons*/
	text-decoration:none;
	background-image:none;
	-moz-border-radius:5px;
	-webkit-border-radius:5px;
	border-radius:5px;
	display:inline-block;
	cursor:pointer;
	font-size:16px;
	font-weight:600;
	background-color:#643B0F;	
	color:#ffffff;
	padding:12px 16px;	
}

a:active { /*effect on clicing a button*/
	position:relative;
	top:1px;
}

a.button-color-transparent { /*transparent button*/
	background-color:transparent;
	border:2px solid #ffffff;	
	border-color:#ffffff;
	color:#ffffff;
}

a:hover.button-color-transparent {/*transparent button effect on hovering*/
	background-color:#ffffff;
	color:#3a3c42;
}

a.button-cancel-color {/*cancel or back button color*/
	background-color:#E4B04A;
	color:#643B0F;
}

a.small-button {/*smaller button*/
	font-size:12px;
	padding:5px 10px;	
}

div.upload {
    overflow: hidden;
}

div.upload input {
    display: block;
    opacity: 0;
}

</style>

<script type="text/javascript">
//<![CDATA[

//this is the Maximum width we will show pictures with
var MAX_WIDTH = 1024;           

var videoObj = { 
	audio: false,
	video: true
};

//canvas dimensions are given by the source image
var canvasDimensions = {
	width: 0,
	height: 0
};

var cropDimensions = {
	width: 180,
	height: 240,
	marginTop: 0,
    marginLeft: 0,
    getAspectRatio: function() {
        return cropDimensions.width / cropDimensions.height;
    }
};

var getCumulativeOffset = function(element) {
    var top = 0, left = 0;
    do {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
    } while( element );

    return {
        top: top,
        left: left
    };
};

var getUserMedia, methodpicker, photomaton, video, editor, canvas, crop, resizeHandle, dragImage, reviewButton, reviewer, reviewCanvas, reviewerButtons;

function showEditor() {
	methodpicker.style.display = "none";
	editor.style.display = "none";
	photomaton.style.display = "none";

	editor.style.width = canvas.width + "px";
    editor.style.display = "inline-block";
    
    //place the crop properly
    crop.setAttribute("style","width:" + cropDimensions.width.toString() + "px;height:" + cropDimensions.height.toString() + "px;");
    crop.style.width = cropDimensions.width.toString() + "px";
    crop.style.height = cropDimensions.height.toString() + "px";
    cropDimensions.marginLeft = (( canvas.width - cropDimensions.width ) / 2);
    crop.style["margin-left"] = cropDimensions.marginLeft.toString() + "px";
    cropDimensions.marginTop = ( canvas.height - cropDimensions.height ) / 2;
    crop.style["margin-top"] = cropDimensions.marginTop.toString() + "px";
    reviewButton.style.position = "relative";
    reviewButton.style.top = (canvas.height + 10).toString() + "px";

    var previousPos,
        currentPos,
        isDragging = false,
        isResizing = false,
        cropCumulativeOffset = getCumulativeOffset( crop );

    var onCropDrag = function (event) {
    	event.preventDefault();
        if ( isDragging && !isResizing ) {
            previousPos = currentPos;
            currentPos = [parseInt(event.clientX), parseInt(event.clientY)];

            var cropDimensionsMarginLeft = cropDimensions.marginLeft + (currentPos[0] - previousPos[0]);
            if ( cropDimensionsMarginLeft >= 0 && cropDimensionsMarginLeft + cropDimensions.width < canvas.width ) {
                cropDimensions.marginLeft = cropDimensionsMarginLeft;
                crop.style["margin-left"] = cropDimensions.marginLeft.toString() + "px";
            }
            var cropDimensionsMarginTop = cropDimensions.marginTop + (currentPos[1] - previousPos[1]);
            if ( cropDimensionsMarginTop >= 0 && cropDimensionsMarginTop + cropDimensions.height < canvas.height ) {
                cropDimensions.marginTop = cropDimensionsMarginTop;
                crop.style["margin-top"] = cropDimensions.marginTop.toString() + "px";
            }
        }
        return false;
    }

    // Grab and move the crop
    crop.ondragstart = function ( event ) {
        if ( !isResizing ) {
            isDragging = true;
            
            previousPos = [parseInt(event.clientX), parseInt(event.clientY)];
            currentPos = [parseInt(event.clientX), parseInt(event.clientY)];
            //next line is some Firefox crap where you need to set some data to be able to drag
            event.dataTransfer.setData('Text', "javascript:void(0);");

            if ( event.dataTransfer.setDragImage ) {
	            //to get rid of the dragImage, replace it with an empty SVG
	            //note that the dragImage must be a visible node, that's why we add it to the DOM
	            event.dataTransfer.setDragImage(dragImage,0,0);
            }

            document.addEventListener("dragover", onCropDrag, true);
        }
    };

    crop.ondragend = function (event) {
        isDragging = false;
        
        document.removeEventListener("dragover", onCropDrag, true);
        
        cropCumulativeOffset = getCumulativeOffset( crop )
    };

    crop.ondrop = function (event) {
    	event.preventDefault();
        if ( event.stopPropagation ) {
            event.stopPropagation();
        }
        return false;
    }

    var onCropResize = function (event) {
        event.preventDefault();
        if ( isResizing && !isDragging ) {
            var mouseX = parseInt(event.clientX);
            var mouseY = parseInt(event.clientY);

            var newWidth = 0;
            var newHeight = 0;

            var xAxisValue = 0;
            var yAxisValue = 0;
            //compute the corner for this mouseX value
            var mouseXRelativeToCrop = (mouseX - cropCumulativeOffset.left);
            var mouseYRelativeToCrop = mouseY - (cropCumulativeOffset.top - window.pageYOffset);
            if ( mouseXRelativeToCrop <= 0 ) {
                //The mouse is to the left of the top left corner
                //for now do nothing.
                //TODO: do something.
            } else {
                //X coordinate of the corner when Y = mouseY
                xAxisValue = mouseYRelativeToCrop * cropDimensions.getAspectRatio();
            }

            if ( mouseYRelativeToCrop <= 0 ) {
                //The mouse is over the top left corner
                //for now do nothing.
                //TODO: do something.
            } else {
                //Y coordinate of the corner when X = mouseX
                yAxisValue = mouseXRelativeToCrop / cropDimensions.getAspectRatio();
            }

            if ( Math.abs( xAxisValue - mouseXRelativeToCrop ) <  Math.abs( yAxisValue - mouseYRelativeToCrop ) ) {
                //the closest corner is close to the X axis
                //redraw at this position
                var newWidth = xAxisValue;
                crop.style["width"] = newWidth.toString() + "px";
                
                cropDimensions.height = (newWidth / cropDimensions.getAspectRatio());
                cropDimensions.width = newWidth; 
                crop.style["height"] = cropDimensions.height.toString() + "px";
            } else {
                //the closest corner is close to the Y axis
                var newHeight = yAxisValue;
                crop.style["height"] = newHeight.toString() + "px";
                
                cropDimensions.width = (newHeight * cropDimensions.getAspectRatio()); 
                cropDimensions.height = newHeight;
                crop.style["width"] = cropDimensions.width.toString() + "px";
            }
        }
    }

    //Resize the crop
    resizeHandle.ondragstart = function (event) {
        if ( !isDragging ) {
            isResizing = true;

            //next line is some Firefox crap where you need to set some data to be able to drag
            event.dataTransfer.setData("Text", "javascript:void(0);");

            if ( event.dataTransfer.setDragImage ) {
	            //to get rid of the dragImage, replace it with an empty SVG
	            //note that the dragImage must be a visible node, that's why we add it to the DOM
	            event.dataTransfer.setDragImage(dragImage,0,0);
            }
            
			document.addEventListener("dragover", onCropResize, true);
        }
    };

    resizeHandle.ondragend = function (event) {
        event.preventDefault();
        isResizing = false;
        
        document.removeEventListener("dragover", onCropResize, true);
    };

    resizeHandle.ondragleave = function (event) {
        event.preventDefault();
    };

    resizeHandle.ondragexit = function (event) {
        event.preventDefault();
    };

    resizeHandle.ondrop = function (event) {
        event.preventDefault();
    };
}

//This is called in the reviewer to go back and crop differently
function goBackToEditor() {
	methodpicker.style.display = "none";
	photomaton.style.display = "none";
	reviewer.style.display = "none";
	editor.style.display = "inline-block";
}

function showReviewer() {
	methodpicker.style.display = "none";
	photomaton.style.display = "none";
	editor.style.display = "none";
	
	var image = canvas.toDataURL();
    var img = new Image();
    img.src = image;
    var context = reviewCanvas.getContext("2d");
    img.onload = function() {
    	reviewCanvas.width = cropDimensions.width;
    	reviewCanvas.height = cropDimensions.height;
        
    	context.drawImage(img, cropDimensions.marginLeft, cropDimensions.marginTop, cropDimensions.width, cropDimensions.height, 0, 0, cropDimensions.width, cropDimensions.height);
    	
    	reviewer.style.width = cropDimensions.width + "px";
    	reviewer.style.display = "inline-block";

    	reviewerButtons.style.top = (reviewCanvas.height + 10).toString() + "px";
	};
}

function showPhotomaton() {
	methodpicker.style.display = "none";
	photomaton.style.display = "inline-block";
	reviewer.style.display = "none";
	
	function startVideoAndAdjustUI() {
		//Trigger photo take
		photomaton.style.width = (video.videoWidth).toString() + "px";
		var takePhotoBtn = document.getElementById("takePhotoBtn");
		takePhotoBtn.parentNode.style.top = (video.videoHeight * 0.8).toString() + "px"; 
		takePhotoBtn.parentNode.style.width = (video.videoWidth).toString() + "px";
		takePhotoBtn.parentNode.style.display = "inline-block";
		takePhotoBtn.addEventListener("click", function() {
			var context = canvas.getContext("2d");
			canvas.width = video.videoWidth;
			canvas.height = video.videoHeight;
			
	        context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
	
	        //Stop the video
	        track.stop();
	        
	        //Switch the video and the canvas
	        photomaton.style.display = "none";
	
	        showEditor();
		});
	}
	
	// Grab elements, create settings, etc.
	var errBack = function(error) {
			console.log("Video capture error: ", error.code); 
		},
		track;

	// Put video listeners into place
	if(navigator.getUserMedia) { // Standard
		navigator.getUserMedia(videoObj, function(stream) {
			//only 1 media stream
			track = stream.getTracks()[0];

			video.addEventListener('loadedmetadata', function() {
				startVideoAndAdjustUI();
			}, false);
			
			if (typeof (video.srcObject) !== 'undefined') {
		        video.srcObject = stream;
		    } else {
		        video.src = URL.createObjectURL(stream);
		    }		
			video.play();
		}, errBack);
	} else if(navigator.webkitGetUserMedia) { // WebKit-prefixed
		navigator.webkitGetUserMedia(videoObj, function(stream){
			track = stream.getTracks()[0];

			video.addEventListener('loadedmetadata', function() {
				startVideoAndAdjustUI();
			}, false);
			
			video.src = window.webkitURL.createObjectURL(stream);
			video.play();
		}, errBack);
	} else if(navigator.mozGetUserMedia) { // Firefox-prefixed
		navigator.mozGetUserMedia(videoObj, function(stream){
			track = stream.getTracks()[0];

			video.addEventListener('loadedmetadata', function() {
				startVideoAndAdjustUI();
			}, false);
			
			video.src = window.URL.createObjectURL(stream);
			video.play();
		}, errBack);
	}
}

function saveCroppedImage() {
	var saveData = (function () {
		if ( window.navigator.msSaveOrOpenBlob ) {
			//To support older IEs.
			return function (blob, fileName) {
				window.navigator.msSaveOrOpenBlob(blob, fileName);
			}
		} else {
			//To support everything else
		    var a = document.createElement("a");
		    a.style.display= "none";
		    document.body.appendChild(a);
		    return function (blob, fileName) {
		    	if(window.navigator.msSaveOrOpenBlob) {
			    	window.navigator.msSaveOrOpenBlob(blob, fileName);
		        } else {
		            var url = window.URL.createObjectURL(blob);
			        a.href = url;
			        a.download = fileName;
			        a.click();
			        setTimeout(function(){
			            document.body.removeChild(a);
			            window.URL.revokeObjectURL(url);  
			        }, 100);
		        }
		    };
		}
	}());
	
	var dataURL = reviewCanvas.toDataURL("image/png");
	var data = atob( dataURL.replace(/^.*?base64,/, '') );
	asArray = new Uint8Array(data.length);
	for( var i = 0, len = data.length; i < len; ++i ) {
	    asArray[i] = data.charCodeAt(i);    
	}
    var blob = new Blob( [ asArray.buffer ], { type: "image/png" } );
    saveData(blob, "image.png");
    
	return false;
}

function handleLocalFile( file ) {
	// generate a new FileReader object
	var reader = new FileReader();

	// inject an image with the src url
	reader.onload = function(event) {
		var image = event.target.result;
	    var img = new Image();
	    img.src = image;
	    
	    img.onload = function() {
	    	var context = canvas.getContext("2d");
	    	if ( this.width > MAX_WIDTH ) {
	    		canvas.width = MAX_WIDTH;
	    		canvas.height = MAX_WIDTH  / this.width * this.height;

	    		context.drawImage(this,0,0,this.width,this.height,0,0,canvas.width,canvas.height);
	    	} else {
	    		canvas.width = this.width;
	    		canvas.height = this.height;
		        
		    	context.drawImage(this, 0, 0);
		    }
	    	
	    	showEditor();
		};
	}
	 
	// when the file is read it triggers the onload event above.
	reader.readAsDataURL(file);
}

//<![CDATA[
// Put event listeners into place
window.addEventListener("DOMContentLoaded", function() {
	methodpicker = document.getElementById("methodpicker");
	photomaton = document.getElementById("photomaton");
	video = document.getElementById("video");
	editor = document.getElementById("editor");
	canvas = document.getElementById("canvas");
	crop = document.getElementById("crop");
	resizeHandle = document.getElementById("resize-handle");
	dragImage = document.getElementById("dragImage");
	reviewButton = document.getElementById("reviewButton");
	reviewer = document.getElementById("reviewer");
	reviewCanvas = document.getElementById("reviewCanvas"),
	reviewerButtons = document.getElementById("reviewerButtons");

	if( !(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) ) {
		document.getElementById("photomatonBtn").style.display = "none";
	}
}, false);
//]]>
</script>
</head>

<div id="photoeditor" style="display:block;text-align:center;width:100%;">

	<div id="methodpicker" style="display:inline-block;width:500px;margin:auto;">
		<div id="upload" class="button upload" style="position:relative;">Choose a file...
			<input type="file" onchange="handleLocalFile(this.files[0]);" style="position:absolute;top:0px;left:0px;height:100%;width:100%;"></input>
		</div>

		<a id="photomatonBtn" onclick="showPhotomaton();" style="vertical-align:top;">Take Picture</a>		
	</div>
		
	<div id="photomaton" style="display:none;position:relative;">
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<video id="video">
		</div>
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<div style="display:none;position:relative;margin:auto;color:#FFF;text-align:center;font-size:20px;padding:10px 0;">
				<a id="takePhotoBtn" class="button-color-transparent">Take Photo</a>
			</div>
		</div>
	</div>
	
	<div id="editor" style="display:none;position:relative;">
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<canvas id="canvas"></canvas>
		</div>
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<div id="crop" draggable="true" class="crop" >
				<div id="resize-handle" class="resize-handle" draggable="true"></div>
			</div>
			
        	<a id="reviewButton" onclick="showReviewer();">Review</a>
		</div>
    </div>
	
	<div id="reviewer" style="display:none;position:relative;">
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<canvas id="reviewCanvas"></canvas>
		</div>
		<div style="position:absolute;top:0px;left:0px;width:100%;">
			<div id="reviewerButtons" style="position:absolute;width:100%;">
				<a onclick="goBackToEditor();" style="float:left;" class="button-cancel-color small-button">Back</a>
				<a href="#" onclick="saveCroppedImage(this);" style="float:right;" class="small-button">Save</a>
			</div>
		</div>
	</div>
	
	<svg id="dragImage" style="height:0px;width:0px;"></svg>
</div>


</html>
